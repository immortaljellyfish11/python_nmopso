# 紧急修复记录 (2025-12-26)

## 问题概述
用户报告运行main.py后路径"直接穿过障碍物"，且compare_algorithms.py报错ValueError: probabilities contain NaN。

## 根本原因分析

### 1. grid.py的NaN错误
**问题**：
- select_leader()函数在计算score_prob时，当所有粒子评分相同时，`score_prob.sum()`为0
- 除以0导致NaN，传递给np.random.choice()报错

**修复**：
```python
# 检查sum避免NaN
score_sum = score_prob.sum()
if score_sum > 1e-10:
    score_prob = score_prob / score_sum
else:
    # 如果所有评分相同，均匀分布
    score_prob = np.ones_like(score_prob) / len(score_prob)
```

### 2. 障碍物配置问题（主要问题）
**问题**：
- 起点高度：140
- 终点高度：180
- **最高障碍物顶部：400**（障碍7和8）
- 智能初始化沿起终点直线飞行，必然穿过高障碍物
- 导致100%碰撞率，存档始终为0

**测试结果（修复前）**：
```
最高障碍物顶部: 400.0
路径 1: J1=0.223, J2=inf (碰撞)
路径 2: J1=0.218, J2=inf (碰撞)
路径 3: J1=0.239, J2=inf (碰撞)
路径 4: J1=0.231, J2=inf (碰撞)
路径 5: J1=0.220, J2=inf (碰撞)
```

**修复方案**：
1. 降低所有障碍物高度：
   - 低空障碍：80-120（原150-180）
   - 中空障碍：110-140（原220-280）
   - 高空障碍：100-120（原280-300）
2. 提高起终点高度：
   - 起点：200（原140）
   - 终点：220（原180）

**测试结果（修复后）**：
```
最高障碍物顶部: 180.0
路径 1: J1=inf, J2=0.000 (可行，无碰撞)
路径 2: J1=inf, J2=0.000 (可行，无碰撞)
路径 3: J1=inf, J2=0.000 (可行，无碰撞)
路径 4: J1=inf, J2=0.000 (可行，无碰撞)
路径 5: J1=0.219, J2=0.000 (可行，无碰撞)
```

## 修改的文件

### 1. grid.py (第176-187行)
```python
# 修改前：
score_prob = np.power(member_scores, 2)
score_prob = score_prob / score_prob.sum()

# 修改后：
score_prob = np.power(member_scores, 2)
score_sum = score_prob.sum()
if score_sum > 1e-10:
    score_prob = score_prob / score_sum
else:
    score_prob = np.ones_like(score_prob) / len(score_prob)
```

### 2. config_enhanced.py (第110-128行)
```python
# 修改前：
model['threats'] = np.array([
    [150, 150, 150, 50, 0],
    [300, 200, 180, 60, 0],
    ...
    [500, 650, 300, 70, 100],  # 最高400
    [350, 550, 280, 65, 80],   # 最高360
])

# 修改后：
model['threats'] = np.array([
    [150, 150, 100, 50, 0],    # 降低
    [300, 200, 120, 60, 0],    # 降低
    ...
    [500, 650, 100, 70, 80],   # 最高180
    [350, 550, 120, 65, 60],   # 最高180
])
```

### 3. config_enhanced.py (第130-132行)
```python
# 修改前：
model['start'] = np.array([50, 50, 140])
model['end'] = np.array([800, 800, 180])

# 修改后：
model['start'] = np.array([50, 50, 200])
model['end'] = np.array([800, 800, 220])
```

## 验证方法

### 测试1：运行test_simple_path.py
```bash
python test_simple_path.py
```
预期：J2=0.000（无碰撞）

### 测试2：运行main.py
```bash
python main.py
```
预期：存档大小>0，出现可行解

### 测试3：运行compare_algorithms.py
```bash
echo "1" | python compare_algorithms.py
```
预期：无NaN错误，正常收敛

## 注意事项

1. **障碍物高度必须低于起终点高度**，否则直线路径必然碰撞
2. **vertical_margin=2** 已经足够小，无需进一步调整
3. **danger_dist=8** 合理，避让距离适中
4. **智能初始化**沿直线飞行，需要确保直线路径至少部分可行

## 后续建议

如果仍想使用更高的障碍物：
1. 方案A：进一步提高起终点高度（如250-270）
2. 方案B：修改智能初始化，让初始路径向上绕行
3. 方案C：增加"地面爬行"策略，从障碍物侧面绕过

当前配置（障碍≤180，起终点200/220）是最稳健的方案。
